#include "chatlistview.h"
#include <QApplication>
#include <QDebug>
#include <QPainter>
#include <QStyleOptionViewItem>

ChatListView::ChatListView(QWidget *parent)
    : QListView(parent)
{
    hoverTimer = new QTimer(this);
    hoverTimer->setSingleShot(true);
    hoverTimer->setInterval(100); // Short delay to prevent flickering
    connect(hoverTimer, &QTimer::timeout, this, [this]() { update(); });
}

void ChatListView::mouseMoveEvent(QMouseEvent *event)
{
    QListView::mouseMoveEvent(event);
    updateHoveredItem(event->pos());
    lastMousePos = event->pos();
    qDebug() << "ChatListView::mouseMoveEvent lastMousePos:" << lastMousePos;
}

void ChatListView::mousePressEvent(QMouseEvent *event)
{
    QListView::mousePressEvent(event);

    // Check if delete button was clicked
    const QModelIndex index = indexAt(event->pos());
    if (index.isValid()) {
        // Calculate button position based on item rect
        QRect itemRect = visualRect(index);
        QRect deleteButtonRect = itemRect;
        deleteButtonRect.setLeft(deleteButtonRect.right() - 30);
        deleteButtonRect.setWidth(25);
        deleteButtonRect.setTop(deleteButtonRect.top() + 5);
        deleteButtonRect.setHeight(20);

        if (deleteButtonRect.contains(event->pos())) {
            // Emit signal for delete
            emit deleteChatRequested(index.row());
        }
    }
}

void ChatListView::leaveEvent(QEvent *event)
{
    QListView::leaveEvent(event);
    qDebug() << "ChatListView::leaveEvent hoveredRow:" << hoveredRow;
    hoveredRow = -1;
    update();
}

void ChatListView::paintEvent(QPaintEvent *event)
{
    QListView::paintEvent(event);

    qDebug() << "ChatListView::hideDeleteButtonForItem hoveredRow:" << hoveredRow;

    // Paint delete buttons for hovered items
    if (hoveredRow >= 0) {
        const QModelIndex index = model()->index(hoveredRow, 0);
        if (index.isValid()) {
            QRect itemRect = visualRect(index);
            QRect deleteButtonRect = itemRect;
            deleteButtonRect.setLeft(deleteButtonRect.right() - 30);
            deleteButtonRect.setWidth(25);
            deleteButtonRect.setTop(deleteButtonRect.top() + 5);
            deleteButtonRect.setHeight(20);

            QPainter painter(viewport());
            painter.setRenderHint(QPainter::Antialiasing);
            painter.setBrush(Qt::red);
            painter.drawRect(deleteButtonRect);

            // Draw X symbol
            painter.setPen(Qt::white);
            painter.drawLine(deleteButtonRect.left() + 4, deleteButtonRect.top() + 6, deleteButtonRect.right() - 4, deleteButtonRect.bottom() - 6);
            painter.drawLine(deleteButtonRect.left() + 4, deleteButtonRect.bottom() - 6, deleteButtonRect.right() - 4, deleteButtonRect.top() + 6);
        }
    }
}

void ChatListView::updateHoveredItem(const QPoint &pos)
{
    qDebug() << "ChatListView::updateHoveredItem pos:" << pos;

    const QModelIndex index = indexAt(pos);
    int newRow = index.isValid() ? index.row() : -1;

    if (newRow != hoveredRow) {
        hoveredRow = newRow;
        hoverTimer->start();
    }
}

void ChatListView::showDeleteButtonForItem(int row)
{
    qDebug() << "ChatListView::showDeleteButtonForItem row:" << row;

    if (row != hoveredRow) {
        hoveredRow = row;
        update();
    }
}

void ChatListView::hideDeleteButtonForItem(int row)
{
    qDebug() << "ChatListView::hideDeleteButtonForItem row:" << row;

    if (row == hoveredRow) {
        hoveredRow = -1;
        update();
    }
}
